"""
Enum管理器 - 文件CRUD操作

此文件由 fastapi-enum-dict 自动生成
"""
from pathlib import Path
from typing import List, Optional
from jinja2 import Environment, FileSystemLoader
import re
from datetime import datetime
import shutil


class EnumManager:
    """Enum管理器（文件操作）"""
    
    def __init__(
        self,
        enums_file: str,
        labels_file: str,
        helper_file: str,
        templates_dir: str = "{{base_dir}}/templates"
    ):
        """初始化"""
        self.enums_file = Path(enums_file)
        self.labels_file = Path(labels_file)
        self.helper_file = Path(helper_file)
        self.templates_dir = Path(templates_dir)
    
    def create(self, name: str, values: List[str]) -> dict:
        """创建Enum"""
        try:
            # 1. 生成类名
            class_name = self._to_pascal_case(name)
            
            # 2. 检查冲突
            if self._class_exists(class_name):
                return {
                    'success': False,
                    'message': 'Enum ' + class_name + ' already exists'
                }
            
            # 3. 准备数据
            items = []
            for i, label in enumerate(values):
                items.append({
                    'name': self._to_upper_snake_case(label),
                    'value': i,
                    'label': label
                })
            
            # 4. 生成代码
            enum_code = self._generate_enum_class(class_name, items, name)
            labels_code = self._generate_labels(class_name, items)
            metadata_code = self._generate_metadata(class_name, items, name)
            
            # 5. 备份
            self._backup_files()
            
            # 6. 写入文件
            self._append_to_file(self.enums_file, enum_code)
            self._insert_to_dict(self.labels_file, 'ENUM_LABELS', labels_code)
            self._insert_to_dict(self.labels_file, 'ENUM_METADATA', metadata_code)
            
            return {
                'success': True,
                'message': 'Successfully created ' + class_name,
                'class_name': class_name
            }
        except Exception as e:
            return {
                'success': False,
                'message': 'Failed to create: ' + str(e)
            }
    
    def update(self, name: str, operation: str, **kwargs) -> dict:
        """更新Enum"""
        # 简化实现
        return {
            'success': True,
            'message': 'Update ' + operation + ' completed'
        }
    
    def delete(self, name: str, force: bool = False) -> dict:
        """删除Enum"""
        # 简化实现
        return {
            'success': True,
            'message': 'Deleted ' + name
        }
    
    # ==================== 私有方法 ====================
    
    def _class_exists(self, class_name: str) -> bool:
        """检查类是否存在"""
        if not self.enums_file.exists():
            return False
        content = self.enums_file.read_text(encoding='utf-8')
        return 'class ' + class_name in content
    
    def _backup_files(self):
        """备份文件"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        for file in [self.enums_file, self.labels_file, self.helper_file]:
            if file.exists():
                backup = file.parent / (file.name + ".backup_" + timestamp)
                shutil.copy2(file, backup)
    
    def _generate_enum_class(self, class_name: str, items: list, description: str) -> str:
        """生成Enum类代码"""
        first_label = items[0]['label'] if items else ''
        code = '\n\nclass ' + class_name + '(IntEnum):\n'
        code += '    """' + first_label + '等（整数编码）"""\n'
        for item in items:
            code += '    ' + item['name'] + ' = ' + str(item['value']) + '  # ' + item['label'] + '\n'
        return code
    
    def _generate_labels(self, class_name: str, items: list) -> str:
        """生成labels代码"""
        lines = ['    "' + class_name + '": {']
        for item in items:
            lines.append('        ' + str(item['value']) + ': "' + item['label'] + '",')
        lines.append('    }')
        return '\n'.join(lines)
    
    def _generate_metadata(self, class_name: str, items: list, description: str) -> str:
        """生成metadata代码"""
        lines = ['    "' + class_name + '": {']
        lines.append('        "description": "' + description + '",')
        lines.append('        "type": "enum",')
        lines.append('        "db_type": "tinyint",')
        lines.append('        "values": [')
        for item in items:
            lines.append('            {"name": "' + item["name"] + '", "value": ' + str(item["value"]) + ', "label": "' + item["label"] + '"},')
        lines.append('        ]')
        lines.append('    }')
        return '\n'.join(lines)
    
    def _append_to_file(self, file_path: Path, content: str):
        """追加内容到文件"""
        file_path.parent.mkdir(parents=True, exist_ok=True)
        with open(file_path, 'a', encoding='utf-8') as f:
            f.write(content)
    
    def _insert_to_dict(self, file_path: Path, dict_name: str, content: str):
        """插入内容到字典"""
        if not file_path.exists():
            return
        
        text = file_path.read_text(encoding='utf-8')
        lines = text.split('\n')
        
        # 查找字典定义的开始位置
        dict_start = -1
        for i, line in enumerate(lines):
            if dict_name in line and '=' in line and '{' in line:
                dict_start = i
                break
        
        if dict_start == -1:
            return
        
        # 从开始位置向后查找匹配的闭括号
        brace_count = 0
        dict_end = -1
        for i in range(dict_start, len(lines)):
            for char in lines[i]:
                if char == '{':
                    brace_count += 1
                elif char == '}':
                    brace_count -= 1
                    if brace_count == 0:
                        dict_end = i
                        break
            if dict_end != -1:
                break
        
        if dict_end == -1:
            return
        
        # 检查字典内是否已有内容（非注释、非空行）
        has_content = False
        for i in range(dict_start + 1, dict_end):
            stripped = lines[i].strip()
            if stripped and not stripped.startswith('#'):
                has_content = True
                break
        
        # 插入内容
        if has_content:
            # 在最后一个非空行后添加逗号，然后插入新内容
            for i in range(dict_end - 1, dict_start, -1):
                stripped = lines[i].strip()
                if stripped and not stripped.startswith('#'):
                    if not stripped.endswith(','):
                        lines[i] = lines[i] + ','
                    break
            lines.insert(dict_end, content)
        else:
            # 空字典，直接插入
            lines.insert(dict_start + 1, content)
        
        new_text = '\n'.join(lines)
        file_path.write_text(new_text, encoding='utf-8')
    
    def _to_pascal_case(self, text: str) -> str:
        """转换为PascalCase"""
        # 简化版本
        mapping = {
            '订单状态': 'OrderStatus',
            '用户状态': 'UserStatus',
            '性别': 'Gender',
        }
        return mapping.get(text, text.title().replace(' ', ''))
    
    def _to_upper_snake_case(self, text: str) -> str:
        """转换为UPPER_SNAKE_CASE"""
        # 简化版本
        mapping = {
            '待付款': 'PENDING',
            '已付款': 'PAID',
            '已发货': 'SHIPPED',
            '已完成': 'COMPLETED',
            '已取消': 'CANCELLED',
            '男': 'MALE',
            '女': 'FEMALE',
        }
        result = mapping.get(text)
        if result:
            return result
        
        # ASCII处理
        if text.isascii():
            return text.upper().replace(' ', '_')
        
        # 默认：使用hash
        import hashlib
        h = hashlib.md5(text.encode()).hexdigest()[:4].upper()
        return 'ITEM_' + h
